{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "805169d8-d4bf-3bfd-a3aa-66ff30935d80",
              "name": "High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification\" is a common security vulnerability in Docker programming. It occurs when a Dockerfile does not specify a non-root user for running the container. By default, Docker containers run as root, which means that if an attacker manages to break out of the container, they would have root access to the host system. This is a significant security concern as it can lead to unauthorized access, data breaches, and potential system damage.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always run your Docker containers as a non-root user. This can be achieved by creating a new user in your Dockerfile and switching to that user before executing any commands. \n\n## Source Code Fix Recommendation\n\nHere is an example of how you can modify your Dockerfile to create a non-root user:\n\n```Dockerfile\nFROM node:14\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN chown -R node:node /app\nUSER node\nCMD [ \"node\", \"server.js\" ]\n```\n\nIn this Dockerfile, we first copy our application and its dependencies into the container. Then, we change the ownership of all files in our application directory to the `node` user. Finally, we switch to the `node` user before starting our application.\n\n## References\n\n- [CWE-250: Execution with Unnecessary Privileges](https://cwe.mitre.org/data/definitions/250.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-250",
                    "url": "https://cwe.mitre.org/data/definitions/250.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-250"
                ]
              }
            },
            {
              "id": "ec718c2c-3bbc-3878-970e-bc468326819b",
              "name": "Validate user input before using in shell commands with imported child_process module.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `child_process` module in JavaScript provides the ability to spawn child processes in a manner that is similar, but not identical, to popen(3). This can be extremely powerful but can also lead to vulnerabilities if not used properly. One such vulnerability is the failure to validate user input before using it in shell commands. This can lead to command injection attacks, where an attacker can execute arbitrary commands on the host operating system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Avoid using shell commands whenever possible. Use native Node.js APIs instead.\n2. If shell commands must be used, avoid including user input in the command. If user input must be included, ensure it is properly sanitized and validated.\n3. Use parameterized APIs or use proper escaping before including user input in a shell command.\n\n## Source Code Fix Recommendation\n\nInstead of using `exec`, use `execFile` or `spawn` which do not use shell to execute the command and hence are safer.\n\n```javascript\nconst { execFile } = require('child_process');\n\nlet user_input = \"...\"; // some user input\n\n// validate user_input here\n\nexecFile('command', [user_input], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\nIn the above code, `execFile` is used instead of `exec`. The command and its arguments are specified as separate strings, which prevents shell metacharacters in `user_input` from being interpreted.\n\n## Library Dependencies\n\nThe code example requires Node.js runtime environment. No additional library dependencies are required.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-78",
                    "url": "https://cwe.mitre.org/data/definitions/78.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-78"
                ]
              }
            },
            {
              "id": "21ea3123-3174-3d79-b784-74a27a5252e9",
              "name": "\"Postgresql Server Vulnerable to MITN Attack due to Disabled TLS: Enforce TLS in Sequelize for Protection\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe provided JavaScript code is a configuration for Sequelize, a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server. The vulnerability here is that the connection to the MySQL server is not using Transport Layer Security (TLS), which can expose the application to Man-In-The-Middle (MITM) attacks. In a MITM attack, the attacker intercepts and possibly alters the communication between two parties who believe they are directly communicating with each other.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should enforce the use of TLS in your Sequelize configuration. This can be done by adding the `ssl` property to the Sequelize configuration and setting it to `true`. \n\n## Source Code Fix Recommendation\n\nHere is how you can modify the Sequelize configuration to enforce the use of TLS:\n\n```javascript\nconst fs = require('fs');\n\nmodule.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql',\n  dialectOptions: {\n    ssl: {\n      require: true,\n      rejectUnauthorized: false\n    }\n  }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- Sequelize: A promise-based Node.js ORM.\n- fs: A built-in Node.js module for file system related operations.\n\n## OWASP and CWE Resources\n\n- [OWASP Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
              "name": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `node-serialize` library in JavaScript is vulnerable to arbitrary code execution. This vulnerability allows an attacker to execute arbitrary code on the server by providing a serialized object with a malicious payload. This is possible because the `node-serialize` library uses the `eval()` function to deserialize objects, which can execute any JavaScript code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using the `node-serialize` library to deserialize untrusted data. If you must use this library, make sure to validate and sanitize the input before deserializing it. \n\n## Source Code Fix Recommendation\n\nInstead of using `node-serialize`, consider using a safer alternative like `JSON.parse()` and `JSON.stringify()`. These functions are built into JavaScript and do not execute code during deserialization.\n\nHere is an example of how to replace `node-serialize` with `JSON`:\n\n```javascript\n// Instead of this:\nvar serialize = require(\"node-serialize\");\nvar obj = serialize.unserialize(serializedData);\n\n// Do this:\nvar obj = JSON.parse(serializedData);\n```\n\n## Library Dependencies\n\nThe code example requires the `node-serialize` library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)\n- [OWASP Node.js Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)\n- [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  },
                  {
                    "id": "CWE-502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-94",
                  "CWE-502"
                ]
              }
            },
            {
              "id": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
              "name": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nXML External Entity (XXE) attacks occur when an XML parser processes XML input that contains a reference to an external entity. This can lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\nIn JavaScript, if a developer uses the `libxmljs` library to parse XML data, the application may be vulnerable to XXE attacks if the XML parser is configured to resolve external entities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should disable the resolution of external entities in the XML parser. This can be done by setting the `noent` option to `false` when parsing XML data.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to disable external entity resolution in `libxmljs`:\n\n```javascript\nvar libxmljs = require(\"libxmljs\");\n\nvar xml = \"...\"; // your XML data\nvar xmlDoc = libxmljs.parseXml(xml, {noent: false});\n```\n\nIn this example, the `noent` option is set to `false`, which disables the resolution of external entities.\n\n## Library Dependencies\n\nThe only library dependency required by the code example is `libxmljs`.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "055908f0-60ec-34e2-99d7-df61704e3569",
              "name": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Path Traversal vulnerability has been detected in the `path.join` or `path.resolve` function due to unsanitized user input. This vulnerability occurs when user input is not properly sanitized before being used in file operations. An attacker can manipulate the input to navigate beyond the intended directory structure, potentially gaining unauthorized access to sensitive files and data.\n\nIn the provided code snippet, the `file` variable is passed directly into the `path.join` function without any sanitization or validation. If an attacker can control the value of `file`, they could potentially access files outside of the intended directory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize all user inputs before using them in file operations. This can be done by checking the input against a whitelist of allowed values, or by using a library function designed to sanitize file paths.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```javascript\nvar path = require('path');\nvar file = req.body.file;\n\n// Validate the input\nif (!file.match(/^[a-z0-9_.-]+$/i)) {\n    throw new Error('Invalid filename');\n}\n\n// Use the sanitized input\nvar model = sequelize.import(path.join(__dirname, file));\n```\n\nIn this example, the `file` variable is checked against a regular expression that only allows alphanumeric characters, underscores, hyphens, and periods. If the input does not match this pattern, an error is thrown.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `path`: a core Node.js module for working with file and directory paths.\n- `sequelize`: a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n- [CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-22"
                ]
              }
            },
            {
              "id": "f9220330-3239-30f0-bb86-58261d761080",
              "name": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `noent` attribute in the `libxmljs` library in JavaScript is used to substitute entities by their values. When it is set to `true`, it can lead to XML External Entity (XXE) vulnerabilities. XXE vulnerabilities occur when an application processing XML input allows the inclusion of dynamic content that is referenced by an external entity. This can lead to the disclosure of confidential data, denial of service, server-side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to disable the `noent` attribute by setting it to `false`. This will prevent the parser from substituting entities by their values, thus preventing potential XXE attacks.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the vulnerability in the provided code:\n\n```javascript\nvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:false,noblanks:true})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `libxmljs`: A library for parsing and serializing XML and HTML to and from JavaScript objects.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
              "name": "\"Undetected CSRF Middleware in Express Application\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is currently authenticated. CSRF attacks specifically target state-changing requests, not theft of data, since the attacker has no way to see the response to the forged request.\n\nIn the context of Express.js applications, if CSRF middleware is not implemented, the application is vulnerable to CSRF attacks. This is because Express.js does not provide built-in CSRF protection, and it must be manually added by the developer.\n\n## Mitigation Advice\n\nTo mitigate CSRF attacks, you should use CSRF tokens. CSRF tokens are unique, random values associated with a user's session. They are typically embedded within forms and validated by the server when the form is submitted. If the token is missing or incorrect, the server can reject the request.\n\nIn Express.js, you can use the `csurf` middleware to implement CSRF protection. This middleware generates a CSRF token and validates it for every state-changing request.\n\n## Source Code Fix\n\nFirst, install the `csurf` middleware:\n\n```bash\nnpm install csurf\n```\n\nThen, use it in your Express.js application:\n\n```javascript\nvar express = require('express')\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\n\nvar csrfProtection = csrf({ cookie: true })\nvar app = express()\n\napp.use(cookieParser())\n\n// Add this middleware to routes that need CSRF protection\napp.post('/process', csrfProtection, function(req, res) {\n  // Process the request...\n})\n```\n\nIn this example, the `csurf` middleware is added to the `/process` route. It generates a CSRF token and validates it when the form is submitted.\n\n## Library Dependencies\n\n- express\n- cookie-parser\n- csurf\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "1b1c4619-f040-3f90-9111-3ca724783e40",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Cross-Site Scripting (XSS) vulnerability from user-controlled data in HTML string is a type of security vulnerability that allows an attacker to inject malicious scripts into web pages viewed by other users. In the context of JavaScript, this vulnerability can occur when user input is used in HTML strings without proper sanitization or validation. \n\nIn the provided code snippet, the user input `req.body.login` is directly used in a SQL query string without any sanitization or validation. This can lead to SQL Injection attacks if the user input contains SQL special characters or commands. Moreover, if the result of this query is used in an HTML string and rendered on a webpage, it can lead to XSS attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate and sanitize user input: Use a library or built-in functions to sanitize and validate user input before using it in SQL queries or HTML strings.\n\n2. Use parameterized queries or prepared statements: This can help prevent SQL Injection attacks as it separates the data from the code.\n\n3. Use Content Security Policy (CSP): CSP can help prevent XSS attacks by restricting the sources of scripts and other resources.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using parameterized queries:\n\n```javascript\nvar sql = \"SELECT name,id FROM Users WHERE login= ?\";\nvar inserts = [req.body.login];\nsql = mysql.format(sql, inserts);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js, used to handle HTTP requests.\n- MySQL: A Node.js driver for MySQL, used to interact with a MySQL database.\n\n## OWASP Resources\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79",
                  "CWE-89"
                ]
              }
            },
            {
              "id": "0960e248-84d3-3502-bcd0-541e59f5ebba",
              "name": "\"SQL Injection Risk from Untrusted Input Concatenation: Use Data Replacement or Binding\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to SQL Injection attacks due to the concatenation of untrusted input directly into a SQL query. This vulnerability arises when an attacker can influence the SQL query by injecting malicious SQL code through the user input, which can lead to unauthorized data access, data corruption, or even data loss.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use parameterized queries or prepared statements, which can ensure that user inputs are properly treated as literal values and not executable code. This can effectively prevent SQL Injection attacks.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using Sequelize's built-in protection against SQL Injection:\n\n```javascript\nvar login = req.body.login;\ndb.User.findAll({\n    where: {\n        login: login\n    }\n}).then(user => {\n    if (user.length) {\n        var output = {\n            user: {\n                name: user[0].name,\n                id: user[0].id\n            }\n        }\n        res.render('app/usersearch', {\n            output: output\n        })\n    } else {\n        req.flash('warning', 'User not found')\n        res.render('app/usersearch', {\n            output: null\n        })\n    }\n}).catch(err => {\n    req.flash('danger', 'Internal Error')\n    res.render('app/usersearch', {\n        output: null\n    })\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express.js: A web application framework for Node.js, used for routing HTTP requests.\n- Connect-flash: A middleware for Express.js to handle flash messages.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
              "name": "Detected Hard-Coded Credential Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nDetected Hard-Coded Credential Vulnerability refers to the insecure practice of embedding plaintext credentials directly within the source code. This vulnerability can lead to unauthorized access, data leakage, and potential system compromise if the source code is exposed or accessible. In JavaScript, this vulnerability is often found when developers hard-code sensitive information like API keys, database credentials, or in this case, a secret key for session management.\n\n## Mitigation Advice\n\nAvoid hard-coding credentials in your source code. Instead, use environment variables, configuration files, or secure vaults to store sensitive information. These methods allow you to separate your credentials from your source code, making it harder for an attacker to gain access to these credentials even if they gain access to your source code.\n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the secret directly in your source code, you can use an environment variable to store the secret. Here's how you can do it:\n\n```javascript\nconst secret = process.env.SECRET || 'default_secret';\n```\n\nIn this example, the secret is read from the `SECRET` environment variable. If the `SECRET` environment variable is not set, 'default_secret' will be used as the secret.\n\n## Library Dependencies\n\nThe specific library dependencies required by the code example to execute properly will depend on the context in which the secret is used. If the secret is used for session management with Express.js, you would need the `express-session` library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A2-Broken Authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication)\n- [OWASP Cheat Sheet: Password Storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-798",
                    "url": "https://cwe.mitre.org/data/definitions/798.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-798"
                ]
              }
            },
            {
              "id": "a46d83fc-ded8-3469-8316-e0528591d6d3",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when user-supplied data is not properly escaped before being inserted into an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\nIn the provided code snippet, the `searchTerm` is directly inserted into the page without being escaped. If an attacker provides a `searchTerm` that includes script tags, they can execute arbitrary JavaScript in the browser of anyone who views the page.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape user-supplied data before inserting it into an EJS template. This can be done using the `<%= %>` syntax, which automatically escapes any HTML special characters.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```ejs\nListing products with <strong>search query: </strong> <%= output.searchTerm %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
              "name": "\"Unspecified Path in Default Session Middleware Settings Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Unspecified Path in Default Session Middleware Settings Vulnerability\" in JavaScript refers to a situation where the path attribute for the session cookie is not explicitly set. This can lead to potential security risks as the cookie becomes accessible to all paths within the domain, which can lead to unauthorized access or session hijacking.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to explicitly set the path attribute for the session cookie. This restricts the cookie to only be accessible within the specified path, reducing the risk of unauthorized access.\n\n## Source Code Fix Recommendation\n\nHere is the recommended fix for the provided code:\n\n```javascript\napp.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { \n    secure: false,\n    path: '/' // specify the path\n  }\n}));\n```\n\nIn this fix, the path attribute is set to '/', which means the cookie will only be accessible within the root path of the domain.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js\n- Express-session\n\n## References\n\n- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [CWE-200: Information Exposure](https://cwe.mitre.org/data/definitions/200.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-200",
                    "url": "https://cwe.mitre.org/data/definitions/200.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-200"
                ]
              }
            },
            {
              "id": "90408b14-a210-379b-a93e-9fa7a1965540",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data before using it in an EJS template. This can be done using the `<%= %>` syntax, which automatically escapes HTML characters. Never use the `<%- %>` syntax with external data, as this does not escape HTML characters.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the provided code:\n\n```javascript\n<td><%= output.products[i].id %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## OWASP Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages. In the provided code, the vulnerability lies in the `.catch(err => {})` block, which is empty and does not handle any errors that might occur during the execution of the Promise.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that Promise rejections are properly handled. This can be done by providing a `.catch()` block that handles any errors that might occur during the execution of the Promise. This block should contain code that handles the error appropriately, such as logging the error and returning a safe, generic error message to the user.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```javascript\ndb.sequelize.query(query, {\n\tmodel: db.User\n}).then(user => {\n\tif (user.length) {\n\t\tvar output = {\n\t\t\tuser: {\n\t\t\t\tname: user[0].name,\n\t\t\t\tid: user[0].id\n\t\t\t}\n\t\t}\n\t\tres.render('app/usersearch', {\n\t\t\toutput: output\n\t\t})\n\t} else {\n\t\treq.flash('warning', 'User not found')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t}\n}).catch(err => {\n\tconsole.error(err);\n\tres.status(500).send('An error occurred while processing your request.');\n});\n```\n\nIn this fix, the `.catch()` block logs the error and sends a generic error message to the user.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- Express.js: A web application framework for Node.js, used for routing and handling HTTP requests and responses.\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "84b854a1-f34b-311e-ba56-c80d48d54711",
              "name": "SQL Injection Vulnerability Prevention through Prepared Statements, Parameterized Queries, and ORM Frameworks",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection is a code injection technique that attackers can use to exploit vulnerabilities in a web application's database layer. This happens when the application's controls allow an attacker to send untrusted data to the interpreter as part of a query. The attacker's hostile data can trick the interpreter into executing unintended commands or accessing unauthorized data.\n\nIn JavaScript, SQL Injection can occur when using libraries such as Sequelize to interact with your database. If user input is directly used in a Sequelize query, an attacker could potentially manipulate the query to perform malicious actions on the database.\n\n## Mitigation Advice\n\nTo prevent SQL Injection vulnerabilities, it's recommended to use Prepared Statements, Parameterized Queries, and ORM Frameworks. \n\n- **Prepared Statements**: These ensure that an application separates the data from the command, which prevents the attacker from manipulating the query.\n\n- **Parameterized Queries**: These require the developer to define all the SQL code, and then pass in each parameter to the query later, which allows the database to distinguish between code and data, regardless of what user input is supplied.\n\n- **ORM Frameworks**: Object-Relational Mapping (ORM) frameworks like Sequelize provide methods that automatically parameterize user input and help prevent SQL Injection attacks.\n\n## Source Code Fix Recommendation\n\nInstead of directly using user input in a Sequelize query, use Sequelize's built-in methods for creating, updating, and querying data. These methods automatically escape user input to prevent SQL Injection attacks.\n\n```javascript\n// Bad: Directly using user input in a query\nlet query = `SELECT * FROM users WHERE name = ${req.body.name}`;\ndb.sequelize.query(query);\n\n// Good: Using Sequelize's built-in methods\ndb.User.findAll({\n  where: {\n    name: req.body.name\n  }\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n- `express`: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application uses untrusted data in the EJS template without proper validation or escaping. This allows an attacker to inject malicious scripts into the web page, which will be executed in the browser of any user viewing that page. This is a type of Cross-Site Scripting (XSS) vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always escape untrusted data before including it in an HTML context. This can be done using the `escape` function provided by EJS or other similar functions provided by other libraries. Additionally, it is also recommended to validate all user inputs to ensure they do not contain any malicious scripts.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `code` property of the `products[i]` object is being outputted without being escaped. This can be fixed by using the `<%= %>` syntax instead of `<%- %>`, which automatically escapes the output. Here is the fixed code:\n\n```javascript\n<td><%= output.products[i].code %></td>\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library dependencies:\n\n- EJS\n\n## OWASP and CWE Links\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, manipulate web content, or perform actions on behalf of the user without their consent.\n\nIn the provided code snippet, the vulnerability arises from the use of `<%-` instead of `<%=`, which results in the output not being escaped:\n\n```javascript\n<td><%- output.products[i].tags %></td>\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data that is being output to the browser. This can be done by using `<%=` instead of `<%-` in EJS templates. This will ensure that any HTML special characters are properly escaped, preventing them from being interpreted as code by the browser.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\n<td><%= output.products[i].tags %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS: A templating engine for JavaScript.\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "266a70bf-e91c-31bb-8b33-7be81335992b",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, manipulate web content, or perform actions on behalf of the user without their consent.\n\nIn the provided code snippet, the product name is being outputted directly into the HTML without any form of escaping or sanitization. If the product name contains any malicious scripts, they will be executed when the page is loaded.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape external data before using it in your templates. This can be done using the `escape` function provided by EJS, or by using a library that provides HTML escaping functionality.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```javascript\n<td><%= ejs.escape(output.products[i].name) %></td>\n```\n\nIn this version, the product name is escaped using the `escape` function provided by EJS. This ensures that any potentially malicious scripts in the product name are not executed.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## OWASP and CWE Links\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "45081c46-bcda-384a-96d1-9d48f46fb46a",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. This allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nEJS (Embedded JavaScript) templates are a popular templating engine in JavaScript. The vulnerability arises when the `<%- %>` syntax is used in EJS templates, which does not escape HTML entities, thus allowing potential Cross-Site Scripting (XSS) attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use the `<%= %>` syntax in EJS templates, which escapes HTML entities and prevents XSS attacks. Never insert untrusted data except in allowed locations and always HTML escape variables used in HTML body, HTML attributes, JavaScript, CSS and URL parameters.\n\n## Source Code Fix Recommendation\n\nReplace the `<%- %>` syntax with `<%= %>` syntax. Here is the fixed code:\n\n```javascript\n<td><%= output.products[i].description %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
              "name": "\"Command Injection Vulnerability through User Input Concatenation\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCommand Injection Vulnerability through User Input Concatenation is a serious security flaw that occurs when an application passes unsafe user-supplied data (forms, cookies, HTTP headers, etc.) to a system shell. In this case, the application allows the user to supply entire command line constructs. The attacker can execute arbitrary commands on the host operating system using a simple interface.\n\nIn the provided JavaScript code, the application is using the `exec` function to execute a shell command that includes user-supplied input (`req.body.address`). This makes the application vulnerable to command injection attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using user input directly in a command that is executed by the system shell. If it's necessary to use user input in a system command, the input should be properly sanitized and validated. \n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using the `child_process.execFile` function, which does not spawn a shell by default:\n\n```javascript\nvar execFile = require('child_process').execFile;\n\nexecFile('ping', ['-c', '2', req.body.address], function(err, stdout, stderr) {\n    output = stdout + stderr;\n    res.render('app/ping', {\n        output: output\n    });\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js (for handling HTTP requests and responses)\n- child_process (built-in Node.js module for executing system commands)\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-78",
                    "url": "https://cwe.mitre.org/data/definitions/78.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-78"
                ]
              }
            },
            {
              "id": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnselected Field Database Query Vulnerability in JavaScript occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query is used to populate a user interface or an API response. An attacker could potentially gain access to data that they are not supposed to see.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done by passing an array of field names to the `attributes` option of the query method. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n  attributes: ['field1', 'field2', 'field3'] // specify the fields to be returned\n}).then(products => {\n  // ...\n});\n```\n\nIn this code, `field1`, `field2`, and `field3` should be replaced with the actual names of the fields that you want to return.\n\n## Library Dependencies\n\nThe code example appears to use Sequelize, a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server. The required library dependencies are:\n\n- `sequelize`: The Sequelize library itself.\n- A database-specific library, such as `pg` for Postgres, `mysql2` for MySQL, etc.\n\n## References\n\n- [OWASP Top Ten 2017: A3-Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-200: Information Exposure](https://cwe.mitre.org/data/definitions/200.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-200",
                    "url": "https://cwe.mitre.org/data/definitions/200.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-200"
                ]
              }
            },
            {
              "id": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled with `.catch()`. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the Promise returned by `db.Product.findAll().then()` is not handled for rejection. If the Promise is rejected (for example, if there is a database error), the rejection will not be caught and the application may crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always handle Promise rejections using `.catch()`. This allows you to control the application's behavior when a Promise is rejected, and to prevent sensitive information from being exposed in error messages.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll().then(products => {\n\toutput = {\n\t\tproducts: products\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn this version, if the Promise is rejected, the rejection is caught and an error message is logged to the console. The server then sends a 500 status code and a generic error message to the client.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A Promise-compatible database library (such as Sequelize) to provide `db.Product.findAll()`.\n- An Express.js-compatible server library to provide `res.render()` and `res.status().send()`.\n\n## References\n\n- [OWASP: Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "caa78969-106f-30a0-815f-8634d1d554c0",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a type of security vulnerability that occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query is used to return data to the client. In the provided code, the `findAll` method is used without specifying the fields to be returned, which means all fields in the `Product` table will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done using the `attributes` option in the `findAll` method. By doing this, only the specified fields will be returned, reducing the risk of exposing sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n    attributes: ['id', 'name', 'price'], // specify the fields to be returned\n    where: {\n        name: {\n            [Op.like]: '%' + req.body.name + '%'\n        }\n    }\n}).then(products => {\n    // ...\n});\n```\n\nIn this fixed version, only the `id`, `name`, and `price` fields will be returned from the `Product` table.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express: A fast, unopinionated, and flexible Node.js web application framework.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
              "name": "Unfiltered Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnfiltered Database Query Vulnerability, also known as NoSQL Injection, is a type of security vulnerability that occurs when an application's code does not properly validate or escape input before using it in a database query. This can allow an attacker to manipulate the query, potentially leading to unauthorized data access, data corruption, or even data loss.\n\nIn the provided JavaScript code, the vulnerability arises from the use of `req.query.id` directly in the database query without any validation or sanitization. This means that an attacker could potentially manipulate the `id` parameter in the request to alter the database query.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize user input before using it in a database query. This can be done using various methods, such as:\n\n- Using prepared statements or parameterized queries, which can ensure that user input is always treated as literal data and not part of the query itself.\n- Using a database abstraction layer or an ORM (Object-Relational Mapping) that automatically escapes user input.\n- Manually escaping special characters in user input that have significance in the query language.\n\n## Source Code Fix Recommendation\n\nIn the provided code, you could use Sequelize's built-in escaping mechanism to sanitize the `id` parameter:\n\n```javascript\ndb.Product.find({\n    where: {\n        'id': Sequelize.escape(req.query.id)\n    }\n}).then(product => {\n```\n\n## Library Dependencies\n\nThe provided code appears to be using the following libraries:\n\n- Express.js: A web application framework for Node.js, used to handle HTTP requests and responses.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP: Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)\n- [OWASP: Injection Prevention Cheat Sheet in Java](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet_in_Java.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or allow for other security vulnerabilities to be exploited.\n\nIn the provided code, the promise returned by `db.Product.find()` is not being properly handled. If the promise is rejected (for example, if there is a problem connecting to the database), there is no error handling mechanism in place to catch and handle the error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always include error handling when working with promises. This can be done by chaining a `.catch()` method to the promise, which will be called if the promise is rejected. The `.catch()` method should take a function that will be called with the error as its argument.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.find({\n\twhere: {\n\t\t'id': req.query.id\n\t}\n}).then(product => {\n\tif (!product) {\n\t\tproduct = {}\n\t}\n\toutput = {\n\t\tproduct: product\n\t}\n\tres.render('app/modifyproduct', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn this version of the code, if the promise returned by `db.Product.find()` is rejected, the function passed to `.catch()` will be called with the error as its argument. This function logs the error and sends a 500 response.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.Product.find()` method. This could be Sequelize, for example.\n- An Express.js-like library that provides the `req.query`, `res.render()`, and `res.status().send()` methods.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
              "name": "XSS Vulnerability in User-Controlled HTML Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the vulnerability lies in the `res.render` function where the `output` object, which includes user-controlled data (`req.body.name`), is passed without any sanitization or encoding. This could allow an attacker to inject malicious scripts by providing specially crafted input.\n\n## Mitigation Advice\n\nTo mitigate XSS vulnerabilities, it's recommended to:\n\n- Use frameworks that automatically escape XSS by design, such as Ruby on Rails, React JS, etc.\n- Escape untrusted HTTP request data based on the context in the HTML output (body, attribute, JavaScript, CSS, or URL) will resolve Reflected and Stored XSS vulnerabilities.\n- Apply context-sensitive encoding when modifying the browser document on the client side acts against DOM XSS.\n\n## Source Code Fix\n\nIn this specific case, you can use the `escape-html` library to escape user input before rendering it:\n\n```javascript\nconst escapeHtml = require('escape-html');\n\ndb.Product.findAll({\n\twhere: {\n\t\tname: {\n\t\t\t[Op.like]: '%' + escapeHtml(req.body.name) + '%'\n\t\t}\n\t}\n}).then(products => {\n\toutput = {\n\t\tproducts: products,\n\t\tsearchTerm: escapeHtml(req.body.name)\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Sequelize (for the `db.Product.findAll` function)\n- Express (for the `req` and `res` objects)\n- escape-html (for escaping HTML entities)\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a type of security vulnerability that occurs when a developer does not explicitly define the fields to be returned in a database query. This can lead to the exposure of sensitive data if the query is manipulated by an attacker. In the provided code, the query is fetching a product by its 'id' from the database without specifying the fields to be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly define the fields to be returned in a database query. This can be done by using the 'select' function in the query and specifying the fields to be returned. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.find({\n\twhere: {\n\t\t'id': req.body.id\n\t},\n\tattributes: ['id', 'name', 'description'] // specify the fields to be returned\n}).then(product => {\n```\n\nIn the fixed code, the 'attributes' option is used to specify the fields to be returned in the query. This ensures that only the 'id', 'name', and 'description' fields of the product are returned, and no other fields are exposed.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies to execute properly:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## OWASP and CWE Resources\n\n- [OWASP - SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to process user input. In the context of JavaScript, this vulnerability can occur when a user is able to manipulate inputs to access unauthorized data. In the provided code, the vulnerability lies in the fact that the user input (`req.body.id`) is directly used to query the database without any validation or sanitization.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement proper access control checks and input validation. This includes:\n\n- Checking if the user is authenticated and authorized to access the requested data.\n- Validating and sanitizing user inputs to prevent SQL Injection attacks.\n- Using parameterized queries or prepared statements to prevent SQL Injection attacks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```javascript\nconst userId = parseInt(req.body.id, 10);\n\nif (isNaN(userId)) {\n    // Handle error: invalid user ID\n}\n\n// Check if the user is authenticated and authorized to access the data\nif (req.user && req.user.id === userId) {\n    db.User.find({\n        where: {\n            'id': userId\n        }\t\t\n    }).then(user => {\n        // Process the user data\n    });\n} else {\n    // Handle error: unauthorized access\n}\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js, used to handle HTTP requests and responses.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "fdc73081-90fc-38f0-8464-db9b877e8c76",
              "name": "\"Unhandled Promise Rejection Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the promise returned by `product.save()` is not properly handled. If the promise is rejected, the `.catch()` block will handle the error, but if the promise is fulfilled with a falsy value (like `null` or `undefined`), the `.then()` block will not handle it and an UnhandledPromiseRejectionWarning will be thrown.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all promises have appropriate error handling. This can be done by always including a `.catch()` block or by using `async/await` with `try/catch`. \n\n## Source Code Fix Recommendation\n\nHere's how you can fix the provided code:\n\n```javascript\nproduct.save().then(p => {\n    if (p) {\n        req.flash('success', 'Product added/modified!')\n        res.redirect('/app/products')\n    } else {\n        throw new Error('Product save failed');\n    }\n}).catch(err => {\n    // Handle the error here\n});\n```\n\nIn this fixed code, if the promise is fulfilled with a falsy value, an error is thrown, which is then caught by the `.catch()` block.\n\n## Library Dependencies\n\nThe provided code seems to be using the following libraries:\n\n- A promise-based database library (like Mongoose) for `product.save()`.\n- Express.js for `req` and `res`.\n- Connect-flash for `req.flash()`.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "5ecfd1ff-67d4-3b5b-9fb9-9a3217839ffe",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the Promise returned by `user.save()` is not properly handled in case of rejection. If the `user.save()` operation fails for any reason, the Promise will be rejected, but this rejection will not be caught, leading to an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by adding a `.catch()` block to the Promise chain, which will be executed in case the Promise is rejected. The `.catch()` block should handle the error appropriately, for example by logging the error and returning a response indicating that an error occurred.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\nuser.save().then(function () {\n\treq.flash('success',\"Updated successfully\")\n\tres.render('app/useredit', {\n\t\tuserId: req.body.id,\n\t\tuserEmail: req.body.email,\n\t\tuserName: req.body.name,\n\t})\n}).catch(function (error) {\n\tconsole.error(error);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn this version, if the `user.save()` operation fails, the error will be logged and a response with status code 500 (Internal Server Error) will be sent.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `user.save()` function. This could be Mongoose if the database is MongoDB, Sequelize if the database is SQL-based, etc.\n- Express.js, for handling HTTP requests and responses.\n- Connect-flash, for the `req.flash()` function.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
              "name": "\"Open Redirect Vulnerability due to User-Controlled Input in URL Building\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nOpen Redirect Vulnerability in URL Building Application is a security flaw in a web application that occurs when an application allows redirection to an external site by directly calling a specific URL in an unfiltered, unmanaged manner. This can be exploited by attackers to conduct phishing attacks, steal user credentials, or perform other malicious activities.\n\nIn JavaScript, this vulnerability can occur when the application uses user input to construct a URL for redirection without validating or sanitizing the input. For example, the following code is vulnerable to open redirect attacks:\n\n```javascript\nres.redirect(req.query.url)\n```\n\nIn this code, `req.query.url` is directly used to redirect the user, which means an attacker can provide a malicious URL to redirect users to a harmful site.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using user input directly to construct a URL for redirection. If it's necessary to use user input, make sure to validate and sanitize the input before using it. You can use a whitelist of allowed URLs for redirection, and only redirect to the URLs that are in the whitelist.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```javascript\nvar allowedUrls = ['http://example.com', 'http://example2.com'];\nif (allowedUrls.indexOf(req.query.url) > -1) {\n    res.redirect(req.query.url);\n} else {\n    // Redirect to a default URL\n    res.redirect('http://defaulturl.com');\n}\n```\n\nIn this code, we only redirect to the URL provided by the user if it's in the whitelist of allowed URLs. Otherwise, we redirect to a default URL.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js\n\n## OWASP Resources\n\n- [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-601"
                ]
              }
            },
            {
              "id": "de1c00f3-1236-30a1-858c-433ce6f12886",
              "name": "\"Code Injection Vulnerability Detected\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Code Injection Vulnerability Detected\" is a security vulnerability that occurs when an attacker can inject and execute malicious code within your application. In JavaScript, this vulnerability can be exploited when user input is processed without proper validation or sanitization. \n\nIn the provided code snippet, the application is using the `mathjs.eval()` function to evaluate a mathematical equation provided by the user. If an attacker provides a malicious JavaScript code instead of a valid equation, the application will execute it, leading to a code injection vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `eval()` or similar functions that can execute arbitrary code. If you need to process user input, make sure to validate and sanitize it before use. \n\n## Source Code Fix Recommendation\n\nInstead of using `mathjs.eval()`, you can use `mathjs.parse()` and `mathjs.compile()` functions which are safer. Here is an example:\n\n```javascript\nconst math = require('mathjs');\nconst parser = math.parser();\n\nlet eqn = req.body.eqn;\nlet sanitizedEqn = parser.parse(eqn).compile().evaluate();\noutput: sanitizedEqn;\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `mathjs`: A comprehensive mathematics library for JavaScript and Node.js.\n\n## OWASP and CWE Resources\n\n- [OWASP Code Injection](https://owasp.org/www-community/attacks/Code_Injection)\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-94"
                ]
              }
            },
            {
              "id": "36d5f6a1-bad0-344e-8212-a75e96f906c7",
              "name": "Sensitive Data Exposure in API Response",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSensitive Data Exposure in API Response is a security vulnerability that occurs when an API unintentionally exposes sensitive information in its responses. This can happen when a developer includes sensitive data in the response object without realizing that it can be accessed by unauthorized users. In the provided JavaScript code, the vulnerability lies in the fact that all user data is being returned in the API response without any filtering or sanitization.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate, sanitize, and filter the data that you send in your API responses.\n2. Never include sensitive data in your API responses unless it's absolutely necessary.\n3. Use access controls to ensure that only authorized users can access sensitive data.\n4. Encrypt sensitive data to add an extra layer of security.\n\n## Source Code Fix Recommendation\n\nIn the provided code, you can mitigate the vulnerability by filtering out the sensitive data from the user objects before sending them in the response. Here's how you can do it:\n\n```javascript\ndb.User.findAll({}).then(users => {\n    const safeUsers = users.map(user => {\n        const { password, ...safeUser } = user;\n        return safeUser;\n    });\n\n    res.status(200).json({\n        success: true,\n        users: safeUsers\n    });\n});\n```\n\nIn this code, we're using the `map` function to create a new array of user objects that don't include the `password` property.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)\n- [CWE-200: Information Exposure](https://cwe.mitre.org/data/definitions/200.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-200",
                    "url": "https://cwe.mitre.org/data/definitions/200.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-200"
                ]
              }
            },
            {
              "id": "58d74204-e872-36aa-836d-ab10502a5418",
              "name": "Insecure Cryptographic Hash Identified: MD5, SHA1 Inadequate for Security; bcrypt, scrypt, Argon2 Recommended for Passwords, SHA-256+ for Integrity Checks.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nInsecure Cryptographic Hash Identified: MD5, SHA1 Inadequate for Security; bcrypt, scrypt, Argon2 Recommended for Passwords, SHA-256+ for Integrity Checks is a vulnerability that arises when cryptographic hash functions with known weaknesses, such as MD5 and SHA1, are used in security-critical contexts. These hash functions are considered insecure because they are susceptible to collision attacks, where two different inputs produce the same hash output, thereby compromising the integrity of the data.\n\nIn JavaScript, this vulnerability can occur when the `md5` library is used to hash sensitive data, such as passwords. The `md5` library is a JavaScript implementation of the MD5 hash function, which is known to be insecure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger cryptographic hash functions, such as bcrypt, scrypt, or Argon2 for password hashing, and SHA-256 or higher for integrity checks. These hash functions are currently considered secure and are not susceptible to collision attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `md5` library with a more secure hash function. For example, you can use the `bcrypt` library for password hashing:\n\n```javascript\nvar bcrypt = require('bcrypt');\nvar saltRounds = 10;\nvar myPlaintextPassword = 's0/\\/\\P4$$w0rD';\n\nbcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) {\n  // Store hash in your password DB.\n});\n```\n\n## Library Dependencies\n\nThe `bcrypt` library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "3b9b1a65-6df9-34c9-865c-92e11c2bd3f6",
              "name": "\"Object or Remote Code Injection Vulnerability in 'unserialize()' or 'deserialize()' Function\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `unserialize()` or `deserialize()` function in JavaScript is used to convert a serialized string back into a JavaScript object. However, this function can be exploited by an attacker to execute arbitrary code on the server. This is known as an Object or Remote Code Injection vulnerability.\n\nThe vulnerability occurs when user-supplied data is passed directly to the `unserialize()` or `deserialize()` function without proper validation. An attacker can craft a serialized string that, when unserialized, results in the execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using the `unserialize()` or `deserialize()` function with user-supplied data. If this is not possible, you should at least validate and sanitize the user-supplied data before passing it to the function.\n\n## Source Code Fix Recommendation\n\nIn the provided code example, the `unserialize()` function is used with data from a file uploaded by the user. This is a potential security risk. A safer approach would be to validate the uploaded file before unserializing its content. Here is a fixed version of the code:\n\n```javascript\nvar productsData = req.files.products.data.toString('utf8');\n\n// Validate productsData before unserializing\nif (isValid(productsData)) {\n    var products = serialize.unserialize(productsData);\n}\n```\n\nIn this code, `isValid()` is a hypothetical function that validates the data. You would need to implement this function according to your specific requirements.\n\n## Library Dependencies\n\nThe provided code example seems to be using the `serialize` library for JavaScript. This library provides the `unserialize()` function. The `req.files.products.data` suggests that the code is also using some kind of file upload middleware, such as `multer`.\n\n## OWASP and CWE Links\n\n- [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n- [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-502"
                ]
              }
            },
            {
              "id": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the `find` method is used to query the `User` database, but no specific fields are selected, meaning all fields associated with the user will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly define the fields to be returned from a database query. This can be done using the `attributes` option in the `find` method. By doing this, only the specified fields will be returned, reducing the risk of exposing sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': req.body.login\n    },\n    attributes: ['login', 'otherField'] // specify the fields to be returned\n}).then(user => {\n    // ...\n});\n```\n\nIn this fixed code, only the `login` and `otherField` fields will be returned from the query.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- `express`: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP - Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "c5680213-67cb-3707-9b6c-1ce025528422",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the promise returned by `db.User.find()` is not being handled for a case where it might get rejected. This could happen, for example, if there is a problem connecting to the database.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain, which will handle any errors that occur in the preceding `.then()` blocks.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.body.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\t// Send reset link via email happens here\n\t\treq.flash('info', 'Check email for reset link')\n\t\tres.redirect('/login')\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\treq.flash('danger', \"An error occurred\")\n\tres.redirect('/forgotpw')\n});\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A database library that provides the `db.User.find()` function. This could be Sequelize, for example.\n- Express.js, for handling HTTP requests and responses.\n- The `req.flash()` function suggests that the `connect-flash` middleware is being used for storing messages in the session.\n- The `res.redirect()` function suggests that the `express` library is being used for routing.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "7b866c05-60b3-3d40-8e2b-070af8617634",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the `find` method is used to query the `User` database with a `login` parameter from the request query. If the query is successful, it returns all fields associated with the user, which may include sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly define the fields to be returned from a database query. This can be done by passing an object to the `find` method that specifies the fields to include or exclude.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': req.query.login\n    },\n    attributes: ['login', 'name', 'email'] // specify the fields to return\n}).then(user => {\n    // ...\n});\n```\n\nIn this fixed version, the `attributes` option is used to specify the fields to be returned from the query. Only the `login`, `name`, and `email` fields will be returned.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- `express`: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-200: Information Exposure](https://cwe.mitre.org/data/definitions/200.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-200",
                    "url": "https://cwe.mitre.org/data/definitions/200.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-200"
                ]
              }
            },
            {
              "id": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, crashes, and potential security vulnerabilities. In the provided code, the promise returned by `db.User.find()` is not properly handled in case of a rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always handle promise rejections by providing a `.catch()` block or by using `try/catch` with async/await. This allows you to handle any errors that occur during the execution of the promise and prevent the application from crashing or behaving unexpectedly.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.query.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\tres.render('resetpw', {\n\t\t\t\tlogin: req.query.login,\n\t\t\t\ttoken: req.query.token\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\tres.redirect('/forgotpw')\n\t\t}\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\treq.flash('danger', \"An error occurred\")\n\tres.redirect('/forgotpw')\n});\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A database library that provides the `db.User.find()` method. This could be Sequelize, Mongoose, or a similar library.\n- Express.js for handling HTTP requests and responses.\n- The `md5` library for hashing.\n- A flash messaging library, such as `connect-flash`, for displaying flash messages.\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "5640a9f3-0a6b-31b1-89b7-afa1ae4a5298",
              "name": "MD5 User-Controlled Input Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nMD5 User-Controlled Input Vulnerability in JavaScript refers to a security flaw where an attacker can manipulate the input to the MD5 hash function, potentially leading to unauthorized access or other security breaches. In the provided code snippet, the application is comparing a user-provided token (req.query.token) with the MD5 hash of another user-provided input (req.query.login). If an attacker can predict or control both inputs, they can potentially bypass the security check.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using MD5 for security-critical purposes, as it is considered to be broken in terms of collision resistance. Instead, use a more secure hash function like SHA-256. Also, avoid directly comparing user-provided inputs for authentication or other security-critical operations. Instead, use a secure method of storing and comparing passwords, such as bcrypt or scrypt.\n\n## Source Code Fix Recommendation\n\nHere's a simple fix using bcrypt:\n\n```javascript\nconst bcrypt = require('bcrypt');\n\n// Hash the login when storing it\nlet hash = bcrypt.hashSync(req.query.login, 10);\n\n// Then, when checking the token, use bcrypt's compareSync function\nif (bcrypt.compareSync(req.query.token, hash)) {\n  // The tokens match\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- bcrypt\n\n## References\n\n- [OWASP - Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n- [OWASP - Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-328: Reversible One-Way Hash](https://cwe.mitre.org/data/definitions/328.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-328"
                ]
              }
            },
            {
              "id": "cf96834b-e589-3399-b7af-68f942a5a2e7",
              "name": "Unhandled Promise Rejections Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejections Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes and potential security vulnerabilities. In the provided code, the promise returned by `user.save()` is not handled properly. If the promise is rejected (for example, if there is a problem saving the user), the error will not be caught and handled, potentially leading to a crash or other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always have a `.catch()` block for every `.then()` block in your promises. This ensures that any errors that occur during the execution of the promise are caught and handled appropriately. \n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': req.body.login\n    }\n}).then(user => {\n    if (user) {\n        if (req.body.token == md5(req.body.login)) {\n            user.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n            user.save().then(function () {\n                req.flash('success', \"Password successfully reset\")\n                res.redirect('/login')\n            }).catch(err => {\n                console.error(err)\n                req.flash('danger', \"An error occurred while resetting password\")\n                res.redirect('/forgotpw')\n            })\n        } else {\n            req.flash('danger', \"Invalid reset token\")\n            res.redirect('/forgotpw')\n        }\n    } else {\n        req.flash('danger', \"Invalid login username\")\n        res.redirect('/forgotpw')\n    }\n}).catch(err => {\n    console.error(err)\n    req.flash('danger', \"An error occurred while finding user\")\n    res.redirect('/forgotpw')\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- Sequelize (for `db.User.find()`)\n- Express.js (for `req`, `res`, and `req.flash()`)\n- bcryptjs (for `bCrypt.hashSync()`)\n- md5 (for `md5()`)\n\n## References\n\n- [OWASP - Unhandled Promise Rejections](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to directly access a system object. In JavaScript, this vulnerability can occur when a user-supplied input is used directly in a database query without proper validation or escaping. This can lead to unauthorized access to sensitive data or even data manipulation.\n\nIn the provided code snippet, the vulnerability lies in the fact that the user input (`req.body.login`) is directly used in a database query without any validation or sanitization. This could potentially allow an attacker to manipulate the query and access or modify data they are not supposed to.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize user inputs: Ensure that the user input matches the expected format and type before using it in a query. This can be done using input validation libraries or built-in JavaScript functions.\n\n2. Implement proper access control: Ensure that the user has the necessary permissions to perform the action they are requesting.\n\n3. Use parameterized queries or prepared statements: This can help prevent SQL injection attacks by ensuring that user input is always treated as a literal value and not part of the SQL command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet using Sequelize's built-in escaping:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': Sequelize.escape(req.body.login)\n    }\n}).then(user => {\n    // ...\n});\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js, used to handle HTTP requests and responses.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "805169d8-d4bf-3bfd-a3aa-66ff30935d80",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Dockerfile",
                  "uriBaseId": "ROOTPATH"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 1,
                  "snippet": {
                    "text": "# Damn Vulnerable NodeJS Application"
                  }
                }
              },
              "message": {
                "text": "Dockerfile"
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8c4694f398bf7b7d993d3a0f21bdf5164ad65fc81141f6fe41a6a1e4053d9cd6",
            "glog-pfp-ruleFileCode/v1": "db6ad433cfd9eac9856351c0b2cc1fc2152696b2a34d332fd9b74afd15ac861f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "db6ad433cfd9eac9856351c0b2cc1fc2152696b2a34d332fd9b74afd15ac861f"
          }
        },
        {
          "ruleId": "21ea3123-3174-3d79-b784-74a27a5252e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Postgresql Server Vulnerable to MITN Attack due to Disabled TLS: Enforce TLS in Sequelize for Protection\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "config/db.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 8,
                  "endColumn": 2,
                  "snippet": {
                    "text": "module.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql'\n}"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18d42c0c0a3fd276b16c0ddc21cf987b591e2aff983815a6d35caa59e1f7545e",
            "glog-pfp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "properties": {}
        },
        {
          "ruleId": "3b9b1a65-6df9-34c9-865c-92e11c2bd3f6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Remote Code Execution Vulnerability via Object Deserialization in serialize.unserialize Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 18,
                  "endLine": 218,
                  "endColumn": 81,
                  "snippet": {
                    "text": "\t\tvar products = serialize.unserialize(req.files.products.data.toString('utf8'))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "19ca046e636ab9b91b643cee55596e145d0bb265b23cf4b159058965b1a59631",
            "glog-pfp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "properties": {}
        },
        {
          "ruleId": "ec718c2c-3bbc-3878-970e-bc468326819b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Validate user input before using in shell commands with imported child_process module."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 14,
                  "endLine": 3,
                  "endColumn": 38,
                  "snippet": {
                    "text": "const exec = require('child_process').exec;"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "150535e095415bccb81b41cd41f2c7b509c6596e0a64f6a49871859a54d39e0a",
            "glog-pfp-ruleFileCode/v1": "44ecf86069e7a88913ef05b440271e3bf2e03c42072a55c1b512b61d735c754d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "44ecf86069e7a88913ef05b440271e3bf2e03c42072a55c1b512b61d735c754d"
          },
          "properties": {}
        },
        {
          "ruleId": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unvalidated User-Supplied URL Redirection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 16,
                  "endLine": 188,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\t\tres.redirect(req.query.url)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7f4ab984071a8244b8127951728d776f45cfba783aa9399325a2f442211f9d5f",
            "glog-pfp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "properties": {}
        },
        {
          "ruleId": "84b854a1-f34b-311e-ba56-c80d48d54711",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential SQL Injection Detected in Sequelize Statement"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 21,
                  "endLine": 11,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "42398eb78168e98670087eae0e8695623926c8b2e10078775df0b1cc1ee3f3c1",
            "glog-pfp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "properties": {}
        },
        {
          "ruleId": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 17,
                  "endLine": 6,
                  "endColumn": 42,
                  "snippet": {
                    "text": "var serialize = require(\"node-serialize\")"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "34b7748288889febaac2b2b37d68336d55da8b77ed3f3eee13a7be52cf685b56",
            "glog-pfp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "properties": {}
        },
        {
          "ruleId": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 16,
                  "endLine": 5,
                  "endColumn": 35,
                  "snippet": {
                    "text": "var libxmljs = require(\"libxmljs\");"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "35ca405e2b602d276a80f54dfee0bedd65c9b289ae9fbb8fee232202ffa70771",
            "glog-pfp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "properties": {}
        },
        {
          "ruleId": "055908f0-60ec-34e2-99d7-df61704e3569",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 55,
                  "endLine": 43,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    var model = sequelize.import(path.join(__dirname, file));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2671bcbc7e8881ce5c1529fe88dd891e4cbac87e364e04e3a05c2e963d30d822",
            "glog-pfp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "properties": {}
        },
        {
          "ruleId": "f9220330-3239-30f0-bb86-58261d761080",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 42,
                  "endLine": 235,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\t\tvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "506d20d987043b34075880eda1b63471d7f1074d3ac7e003bcefc28ade497ce1",
            "glog-pfp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "properties": {}
        },
        {
          "ruleId": "0960e248-84d3-3502-bcd0-541e59f5ebba",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Risk from Untrusted Input and Raw SQL Query Concatenation"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 35,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {\n\t\treq.flash('danger', 'Internal Error')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1085e92bf69b313df40ac8e2e1a276eec8450da2d9485c79ec8d712781dd948a",
            "glog-pfp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "properties": {}
        },
        {
          "ruleId": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability from Using Default Session Cookie Name\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 9,
                  "endLine": 28,
                  "endColumn": 3,
                  "snippet": {
                    "text": "app.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ce69d2a7144ea24780ebefb0c1d53009b4b8f096808c202427ea7f2041b69b5c",
            "glog-pfp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "properties": {}
        },
        {
          "ruleId": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Undetected CSRF Middleware in Express Application\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 5,
                  "endLine": 11,
                  "endColumn": 20,
                  "snippet": {
                    "text": "var app = express()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c9bada67aa30b2f4eef499ae0ca4472c5112206f8b1f915f95e31c71920cec53",
            "glog-pfp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "properties": {}
        },
        {
          "ruleId": "1b1c4619-f040-3f90-9111-3ca724783e40",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 10,
                  "endColumn": 78,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b32668493e03925996444b92fb90d5cde9dc44debd198f9800907690b28cf011",
            "glog-pfp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "properties": {}
        },
        {
          "ruleId": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Hard-Coded Credential Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 24,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  secret: 'keyboard cat',"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc790f145993a88de1a5aa0e57223726c800a5a7e7b13118b6a333d986b0f238",
            "glog-pfp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "properties": {}
        },
        {
          "ruleId": "a46d83fc-ded8-3469-8316-e0528591d6d3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 71,
                  "endLine": 20,
                  "endColumn": 95,
                  "snippet": {
                    "text": "                Listing products with <strong>search query: </strong> <%- output.searchTerm %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "993cce01512140422849249323195d439a005b4b58a35d471011c01600017e9a",
            "glog-pfp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "properties": {}
        },
        {
          "ruleId": "90408b14-a210-379b-a93e-9fa7a1965540",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 21,
                  "endLine": 49,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                <td><%- output.products[i].id %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4599dd340bf56d897d52f230329a557b79cb97e86a3f98364657481c8f35c407",
            "glog-pfp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "properties": {}
        },
        {
          "ruleId": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 2,
                  "endLine": 30,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c5b64d1e95afdc96ec94817996ed9fa4919913e89c2ea399839d1df707c6f6ba",
            "glog-pfp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "properties": {}
        },
        {
          "ruleId": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Command Injection Vulnerability Detected through Non-Literal $EXEC() Calls"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 2,
                  "endLine": 44,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\texec('ping -c 2 ' + req.body.address, function (err, stdout, stderr) {\n\t\toutput = stdout + stderr\n\t\tres.render('app/ping', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c836ff7ece7e99e795ec649e9e58181c3588075e173dfdbe9ae7c1a22a4a3918",
            "glog-pfp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "properties": {}
        },
        {
          "ruleId": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 21,
                  "endLine": 51,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].code %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f68139076127b27a901c42af24d89e06e61541388985b8b0dad6824951912fa3",
            "glog-pfp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "properties": {}
        },
        {
          "ruleId": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 21,
                  "endLine": 52,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].tags %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1afa7e9f36e186fd802d95bbc8636c5ae0c00de7c39a40d00e4e0c03c31b2e5d",
            "glog-pfp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "properties": {}
        },
        {
          "ruleId": "266a70bf-e91c-31bb-8b33-7be81335992b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 21,
                  "endLine": 50,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].name %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e11211defbe7ebd1814bc865b8d48d6499771aff0028cbd96c689144ce449e63",
            "glog-pfp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "properties": {}
        },
        {
          "ruleId": "45081c46-bcda-384a-96d1-9d48f46fb46a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 21,
                  "endLine": 53,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                <td><%- output.products[i].description %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "10ff96811314b638ff52e3b999b576d6a645f52fcbc1cfd0a329e3e99acfe70b",
            "glog-pfp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "properties": {}
        },
        {
          "ruleId": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 48,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "caf6d4570f6b157334a62b557dfd5df1ea4fee4dd1b463172f98cde070607721",
            "glog-pfp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "properties": {}
        },
        {
          "ruleId": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 55,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {\n\t\toutput = {\n\t\t\tproducts: products\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "73310be0d62f3dfc78d1ff16fcb864e4b104e73b4c67aacf6850f14a716b919b",
            "glog-pfp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "properties": {}
        },
        {
          "ruleId": "caa78969-106f-30a0-815f-8634d1d554c0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 65,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9f759e30d4eeeacf1d39668182e6cc6848cc0a6146914b736979c912b91ed97c",
            "glog-pfp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "properties": {}
        },
        {
          "ruleId": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 73,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {\n\t\toutput = {\n\t\t\tproducts: products,\n\t\t\tsearchTerm: req.body.name\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bfa71a8174f21d74aa29f178623cfeb94b3b482472d0d439940538a0671362d6",
            "glog-pfp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "properties": {}
        },
        {
          "ruleId": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 89,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "244f1bd534f117bd3919e03ca082d002d1c269c5c8b34f7047798105d0b2b395",
            "glog-pfp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "properties": {}
        },
        {
          "ruleId": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 99,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {\n\t\t\tif (!product) {\n\t\t\t\tproduct = {}\n\t\t\t}\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a54a8c352c2e2d3ae6622d66d25fa24e36609c89630a6bec97f0c91c16836faf",
            "glog-pfp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "properties": {}
        },
        {
          "ruleId": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unverified User Input IDOR Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 2,
                  "endLine": 111,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\n\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e539eca08d5e8acd6c37edaf7f662a137353aa82d0cebf4336ec53015204c0b4",
            "glog-pfp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "properties": {}
        },
        {
          "ruleId": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 2,
                  "endLine": 149,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cd7f31aba4c9b49ea9f41d97d7baa29165d4189d8fb2db32689f50ffbe3620de",
            "glog-pfp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "properties": {}
        },
        {
          "ruleId": "fdc73081-90fc-38f0-8464-db9b877e8c76",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unhandled Promise Rejection Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 3,
                  "endLine": 124,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tproduct.save().then(p => {\n\t\t\tif (p) {\n\t\t\t\treq.flash('success', 'Product added/modified!')\n\t\t\t\tres.redirect('/app/products')\n\t\t\t}\n\t\t}).catch(err => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "581408cb4a01c77663ce1b06169c91ddba80bc45f13dcb775e8aad39f4547396",
            "glog-pfp-ruleFileCode/v1": "a73791e11dd3af187d5e0f09b3a5ffc0dd3000d389081080adce8dde2a13b935"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a73791e11dd3af187d5e0f09b3a5ffc0dd3000d389081080adce8dde2a13b935"
          },
          "properties": {}
        },
        {
          "ruleId": "5ecfd1ff-67d4-3b5b-9fb9-9a3217839ffe",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 3,
                  "endLine": 182,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tuser.save().then(function () {\n\t\t\treq.flash('success',\"Updated successfully\")\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.body.id,\n\t\t\t\tuserEmail: req.body.email,\n\t\t\t\tuserName: req.body.name,\n\t\t\t})\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1b1a6502e6eb8476e38b691b04e3ceb33891c27b8f68ddb3e8422ea4fe46915d",
            "glog-pfp-ruleFileCode/v1": "00ed32871bfd84989abd351e55bd4c91d745b417b5dcb4c75df21460d2ee9f66"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "00ed32871bfd84989abd351e55bd4c91d745b417b5dcb4c75df21460d2ee9f66"
          },
          "properties": {}
        },
        {
          "ruleId": "de1c00f3-1236-30a1-858c-433ce6f12886",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Deprecated mathjs.eval() is susceptible to code injection; use mathjs.evaluate() instead.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 12,
                  "endLine": 197,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\t\t\toutput: mathjs.eval(req.body.eqn)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2f2e58053cbb67ba42ac007cae9978f34f32cba101be5d31d28d20d31c210bfd",
            "glog-pfp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "properties": {}
        },
        {
          "ruleId": "36d5f6a1-bad0-344e-8212-a75e96f906c7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 2,
                  "endLine": 212,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.findAll({}).then(users => {\n\t\tres.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tusers: users\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c64a7e19f12582c998ff8a54e976b96bba6aac09737c3d252c52706026b0a5c2",
            "glog-pfp-ruleFileCode/v1": "dbebb86eaac74c503baeca7bda62bf65c97943a680c476843bc3026373e8ec14"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "dbebb86eaac74c503baeca7bda62bf65c97943a680c476843bc3026373e8ec14"
          },
          "properties": {}
        },
        {
          "ruleId": "58d74204-e872-36aa-836d-ab10502a5418",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure Cryptographic Hash Identified: MD5, SHA1 Inadequate for Security; bcrypt, scrypt, Argon2 Recommended for Passwords, SHA-256+ for Integrity Checks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 11,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "var md5 = require('md5')"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "26cb90b1bfe6e22e5adba0997ee91178f76882ac7ec1db32db7721df0a507796",
            "glog-pfp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "properties": {}
        },
        {
          "ruleId": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unverified User Input IDOR Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 25,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9043b1d984a1019c3e7303bc7c5411099f5c0715205f13a85a0e25be36279848",
            "glog-pfp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "properties": {}
        },
        {
          "ruleId": "c5680213-67cb-3707-9b6c-1ce025528422",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\t// Send reset link via email happens here\n\t\t\t\treq.flash('info', 'Check email for reset link')\n\t\t\t\tres.redirect('/login')\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18044355b1f701cdc533935d3c8f64ae8778ecabddb2d16eb05daea292c65250",
            "glog-pfp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "properties": {}
        },
        {
          "ruleId": "7b866c05-60b3-3d40-8e2b-070af8617634",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 47,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5907561c300b28b36bdc892914107701ff615f056b40ee9a13c086fe5fcc51cd",
            "glog-pfp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "properties": {}
        },
        {
          "ruleId": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 62,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\t\t\tres.render('resetpw', {\n\t\t\t\t\t\tlogin: req.query.login,\n\t\t\t\t\t\ttoken: req.query.token\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba46914313d3cdde3a6cf3a8251c9de85cda981d9cdf78f3c12c300aa3aef2b2",
            "glog-pfp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "properties": {}
        },
        {
          "ruleId": "5640a9f3-0a6b-31b1-89b7-afa1ae4a5298",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "MD5 User-Controlled Input Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 8,
                  "endLine": 49,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\t\t\t\tif (req.query.token == md5(req.query.login)) {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba7fdd0cfb781e59cbd3f0c29846faa583bff6b69235e115a57c87ce82ec506d",
            "glog-pfp-ruleFileCode/v1": "1cf638db5d0691d600f533a001520e9459dc063317755b9a80a36ca3361b6693"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1cf638db5d0691d600f533a001520e9459dc063317755b9a80a36ca3361b6693"
          },
          "properties": {}
        },
        {
          "ruleId": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 76,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cc03baa18480cc562095135117fc601ca94f761037a179794ae2d07224d681f5",
            "glog-pfp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "properties": {}
        },
        {
          "ruleId": "cf96834b-e589-3399-b7af-68f942a5a2e7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejections Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 92,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {\n\t\t\t\tif (user) {\n\t\t\t\t\tif (req.body.token == md5(req.body.login)) {\n\t\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t\t\tuser.save().then(function () {\n\t\t\t\t\t\t\treq.flash('success', \"Passowrd successfully reset\")\n\t\t\t\t\t\t\tres.redirect('/login')\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "078c75d5164b2b059aa88af3a10c3037bfe3349724377deff793a2bd4cc2a04e",
            "glog-pfp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}